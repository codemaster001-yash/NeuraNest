<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jetpack Mania</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Custom pixel font */
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a202c;
            /* Dark background */
            color: #e2e8f0;
            /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            /* Prevent body scroll */
            flex-direction: column;
            padding: 1rem;
        }

        /* Game Container Styling */
        .game-container {
            background-color: #2d3748;
            /* Darker grey */
            border: 8px solid #4a5568;
            /* Border for retro console look */
            border-radius: 1.5rem;
            box-shadow: 0 0 30px rgba(0, 150, 250, 0.5), 0 0 15px rgba(0, 150, 250, 0.7) inset;
            /* Blue glow effect */
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 500px;
            /* Max width for desktop */
            aspect-ratio: 16 / 10;
            /* Maintain aspect ratio */
            position: relative;
            overflow: hidden;
        }

        /* Canvas Styling - fixed virtual resolution, scaled by CSS */
        canvas {
            background-color: #000000;
            /* Black background for pixel art */
            image-rendering: pixelated;
            /* Crucial for pixel art */
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 0.5rem;
            /* Slightly rounded corners for canvas */
        }

        /* Overlay Modals (Start, Game Over, Instructions) */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            /* Semi-transparent black */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
            padding: 1rem;
            box-sizing: border-box;
            border-radius: 1.5rem;
            /* Match container border-radius */
        }

        .overlay h2 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #63b3ed;
            /* Blue for titles */
        }

        .overlay p {
            font-size: 0.75rem;
            margin-bottom: 0.75rem;
            line-height: 1.4;
            color: #a0aec0;
            /* Grey text */
        }

        .overlay button {
            @apply bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg transition duration-200 ease-in-out transform hover:scale-105 active:scale-95 text-sm uppercase mt-4;
            letter-spacing: 0.05em;
        }

        /* Game HUD */
        .hud {
            position: absolute;
            top: 0.5rem;
            left: 0.5rem;
            right: 0.5rem;
            display: flex;
            justify-content: space-between;
            font-size: 0.6rem;
            /* Smaller font for HUD */
            color: #a0aec0;
            z-index: 5;
        }

        /* Mobile Controls */
        .mobile-controls {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 500px;
            margin-top: 1rem;
            gap: 1rem;
            padding: 0 1rem;
            box-sizing: border-box;
        }

        .mobile-controls button {
            @apply bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-6 rounded-full shadow-lg transition duration-200 ease-in-out transform hover:scale-105 active:scale-95 text-lg opacity-80;
            min-width: 80px;
            /* Ensure buttons are large enough for touch */
            font-size: 1rem;
            flex-grow: 1;
        }

        /* Specific button styling for directional and jump */
        .mobile-controls .direction-btn {
            @apply bg-indigo-600 hover:bg-indigo-700;
        }

        .mobile-controls .action-btn {
            @apply bg-green-600 hover:bg-green-700;
        }

        /* Hide mobile controls on larger screens */
        @media (min-width: 768px) {
            .mobile-controls {
                display: none;
            }
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <h1 class="text-3xl sm:text-4xl text-blue-400 mb-6 text-center leading-tight">JETPACK MANIA!</h1>

    <div class="game-container">
        <div id="game-hud" class="hud hidden">
            <div id="score-display">SCORE: 0</div>
            <div id="lifelines" style="font-size: 1.2rem; color: #ff4d4f; display: flex; gap: 0.3em;">
                <span class="heart">&hearts;</span>
                <span class="heart">&hearts;</span>
                <span class="heart">&hearts;</span>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <!-- Countdown Overlay -->
        <div id="countdown-overlay" class="overlay hidden" style="background: rgba(0,0,0,0.7); z-index:20;">
            <h2 id="countdown-number" style="font-size:3rem; color:#FFD700;">3</h2>
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="overlay">
            <h2>Welcome to Jetpack Mania!</h2>
            <p>Soar through the pixel skies, avoid obstacles, and collect coins!</p>
            <p><strong>GOAL:</strong> Fly as far as possible and collect as many coins as you can!</p>
            <button id="show-instructions-btn">INSTRUCTIONS</button>
            <button id="start-game-btn" class="mt-2">START GAME</button>
            <p class="mt-4 text-xs">Personal Best: <span id="personal-best-display">0</span></p>
        </div>

        <!-- Instructions Screen -->
        <div id="instructions-screen" class="overlay hidden">
            <h2>Instructions</h2>
            <p><strong>Movement:</strong> Use <span class="text-blue-300">&larr; Left Arrow</span> and <span
                    class="text-blue-300">Right Arrow &rarr;</span> keys (Desktop) or <span
                    class="text-blue-300">Left/Right buttons</span> (Mobile).</p>
            <p><strong>Jetpack:</strong> Press <span class="text-blue-300">SPACEBAR</span> (Desktop) or the <span
                    class="text-blue-300">JETPACK button</span> (Mobile) to fly upwards.</p>
            <p><strong>Obstacles:</strong> Avoid colliding with the ground or flying blocks. Collisions end the game!
            </p>
            <p><strong>Coins:</strong> Collect yellow coins to increase your score.</p>
            <button id="back-to-start-btn">BACK</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="overlay hidden">
            <h2>GAME OVER!</h2>
            <p>Your jetpack ran out of fuel!</p>
            <p>Final Score: <span id="final-score-display">0</span></p>
            <p>Personal Best: <span id="game-over-personal-best-display">0</span></p>
            <button id="restart-game-btn">RESTART</button>
        </div>
    </div>

    <!-- Mobile Controls -->
    <div class="mobile-controls">
        <button id="move-left-btn" class="direction-btn">&larr;</button>
        <button id="jetpack-btn" class="action-btn">JETPACK</button>
        <button id="move-right-btn" class="direction-btn">&rarr;</button>
    </div>

    <script>
        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Virtual game resolution (low resolution for pixel art)
        const GAME_WIDTH = 160;
        const GAME_HEIGHT = 100;
        // The size of one "pixel" in our game in actual canvas units
        const PIXEL_SCALE = 4; // Each virtual pixel will be 4x4 actual pixels

        // Set canvas dimensions based on virtual resolution and pixel scale
        canvas.width = GAME_WIDTH * PIXEL_SCALE;
        canvas.height = GAME_HEIGHT * PIXEL_SCALE;

        // UI Elements
        const startScreen = document.getElementById('start-screen');
        const instructionsScreen = document.getElementById('instructions-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const hud = document.getElementById('game-hud');
        const startGameBtn = document.getElementById('start-game-btn');
        const showInstructionsBtn = document.getElementById('show-instructions-btn');
        const backToStartBtn = document.getElementById('back-to-start-btn');
        const restartGameBtn = document.getElementById('restart-game-btn');
        const scoreDisplay = document.getElementById('score-display');
        const finalScoreDisplay = document.getElementById('final-score-display');
        const personalBestDisplay = document.getElementById('personal-best-display');
        const gameOverPersonalBestDisplay = document = document.getElementById('game-over-personal-best-display');

        // Countdown Elements
        const countdownOverlay = document.getElementById('countdown-overlay');
        const countdownNumber = document.getElementById('countdown-number');


        // Mobile Controls
        const moveLeftBtn = document.getElementById('move-left-btn');
        const moveRightBtn = document.getElementById('move-right-btn');
        const jetpackBtn = document.getElementById('jetpack-btn');

        // Add lifelines
        let lifelines = 3;
        const lifelinesDisplay = document.getElementById('lifelines');

        function updateLifelinesDisplay() {
            lifelinesDisplay.innerHTML = '';
            for (let i = 0; i < lifelines; i++) {
                const heart = document.createElement('span');
                heart.className = 'heart';
                heart.innerHTML = '&hearts;';
                lifelinesDisplay.appendChild(heart);
            }
        }

        // --- Game State Variables ---
        let gameState = 'START'; // START, PLAYING, GAME_OVER

        let player = {
            x: GAME_WIDTH / 2 - 4,
            y: GAME_HEIGHT / 2 - 4,
            width: 8,
            height: 8,
            color: '#00FF00', // Green
            speedX: 0,
            velocityY: 0,
            gravity: 0.05, // Slower fall speed
            jetpackThrust: -0.15, // Smaller, slower jumps
        };

        let obstacles = [];
        let coins = [];
        let particles = []; // For jetpack flames and coin collection

        let score = 0;
        let personalBest = localStorage.getItem('jetpackManiaBestScore') ? parseInt(localStorage.getItem('jetpackManiaBestScore')) : 0;

        let keys = {}; // To track pressed keys
        let touchControls = {
            left: false,
            right: false,
            jetpack: false
        };

        let obstacleSpawnTimer = 0;
        let obstacleSpawnInterval = 1500; // ms between obstacle spawns
        let coinSpawnTimer = 0;
        let coinSpawnInterval = 700; // ms between coin spawns
        let backgroundScrollSpeed = 0.5; // Visual scroll speed of background
        let gameSpeed = 1; // Multiplier for overall game speed (obstacles, player vert)

        // --- Game Objects Drawing Functions ---

        /**
         * Draws a pixelated rectangle on the canvas.
         * @param {number} x X-coordinate in virtual pixels.
         * @param {number} y Y-coordinate in virtual pixels.
         * @param {number} width Width in virtual pixels.
         * @param {number} height Height in virtual pixels.
         * @param {string} color CSS color string.
         */
        function drawPixelRect(x, y, width, height, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * PIXEL_SCALE, y * PIXEL_SCALE, width * PIXEL_SCALE, height * PIXEL_SCALE);
        }

        /**
         * Draws pixel art based on a 2D array representation.
         * @param {number} startX X-coordinate of top-left corner in virtual pixels.
         * @param {number} startY Y-coordinate of top-left corner in virtual pixels.
         * @param {Array<Array<string|null>>} pixelArt 2D array of colors (null for transparent).
         */
        function drawPixelArt(startX, startY, pixelArt) {
            for (let y = 0; y < pixelArt.length; y++) {
                for (let x = 0; x < pixelArt[y].length; x++) {
                    const color = pixelArt[y][x];
                    if (color) {
                        drawPixelRect(startX + x, startY + y, 1, 1, color);
                    }
                }
            }
        }

        // Define pixel art for player (jetpack character)
        const playerPixelArt = [
            [null, null, '#FFFF00', '#FFFF00', null, null], /* Head */
            [null, '#00CC00', '#00CC00', '#00CC00', '#00CC00', null], /* Body */
            ['#009900', '#00CC00', '#00CC00', '#00CC00', '#00CC00', '#009900'],
            [null, '#333333', null, null, null, '#333333'], /* Arms */
            ['#CC0000', null, null, null, null, '#CC0000'], /* Legs/Boots */
            ['#666666', '#666666', null, null, '#666666', '#666666'], /* Jetpack */
        ];
        // Jetpack flame particle colors
        const flameColors = ['#FFA500', '#FF4500', '#FFFF00'];

        // Obstacle pixel art (simple block)
        const obstaclePixelArt = [
            ['#663300', '#663300', '#663300', '#663300'],
            ['#663300', '#996633', '#996633', '#663300'],
            ['#663300', '#996633', '#996633', '#663300'],
            ['#663300', '#663300', '#663300', '#663300'],
        ];

        // Coin pixel art
        const coinPixelArt = [
            [null, '#FFFF00', '#FFFF00', null],
            ['#FFFF00', '#FFFF00', '#FFFF00', '#FFFF00'],
            ['#FFFF00', '#FFFF00', '#FFFF00', '#FFFF00'],
            [null, '#FFFF00', '#FFFF00', null],
        ];

        // --- Game Functions ---

        function initGame() {
            player.x = 20; // Start at x=20 instead of center
            player.y = GAME_HEIGHT / 2 - player.height / 2;
            player.speedX = 0;
            player.velocityY = 0;
            obstacles = [];
            coins = [];
            particles = [];
            score = 0;
            obstacleSpawnTimer = Date.now(); // Prevent immediate obstacle spawn
            coinSpawnTimer = Date.now();
            gameSpeed = 1;
            lifelines = 3;
            updateHUD();
            updateLifelinesDisplay();
            personalBest = localStorage.getItem('jetpackManiaBestScore') ? parseInt(localStorage.getItem('jetpackManiaBestScore')) : 0;
            personalBestDisplay.textContent = personalBest;
            gameOverPersonalBestDisplay.textContent = personalBest;
        }

        function startGame() {
            initGame();
            gameState = 'PLAYING';
            startScreen.classList.add('hidden');
            hud.classList.remove('hidden');
            gameLoop();
        }

        function gameOver() {
            gameState = 'GAME_OVER';
            hud.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
            finalScoreDisplay.textContent = score;

            if (score > personalBest) {
                personalBest = score;
                localStorage.setItem('jetpackManiaBestScore', personalBest);
            }
            gameOverPersonalBestDisplay.textContent = personalBest;
        }

        function updateHUD() {
            scoreDisplay.textContent = `SCORE: ${score.toFixed(0)}`; // Show whole number score
        }

        function spawnObstacle() {
            const obstacleWidth = 10; // Fixed width for blocks
            const gap = 20 + Math.floor(Math.random() * 10); // Gap for player to fly through
            const minHeight = 10;
            const maxHeight = GAME_HEIGHT - gap - minHeight;
            const topHeight = minHeight + Math.random() * maxHeight;

            // Only spawn obstacles if their height is positive (visible)
            if (topHeight > 0) {
                // Top obstacle (red)
                obstacles.push({
                    x: GAME_WIDTH,
                    y: 0,
                    width: obstacleWidth,
                    height: topHeight,
                    color: '#FF2222' // Bright red
                });
            }

            const bottomHeight = GAME_HEIGHT - (topHeight + gap);
            if (bottomHeight > 0) {
                // Bottom obstacle (red)
                obstacles.push({
                    x: GAME_WIDTH,
                    y: topHeight + gap,
                    width: obstacleWidth,
                    height: bottomHeight,
                    color: '#FF2222' // Bright red
                });
            }
        }

        function spawnCoin() {
            const size = 4;
            coins.push({
                x: GAME_WIDTH + Math.random() * 20, // Spawn slightly off-screen for variety
                y: Math.random() * (GAME_HEIGHT - size * 2) + size, // Random vertical position
                width: size,
                height: size,
                color: '#FFD700' // Gold
            });
        }

        function createJetpackFlame(x, y) {
            for (let i = 0; i < 3; i++) { // Small number of particles for flame
                particles.push({
                    x: x + player.width / 2 + (Math.random() - 0.5) * 2,
                    y: y + player.height - 1, // Below player
                    size: Math.random() * 2 + 1,
                    color: flameColors[Math.floor(Math.random() * flameColors.length)],
                    speedX: (Math.random() - 0.5) * 0.5,
                    speedY: Math.random() * 0.5 + 0.5, // Downwards
                    alpha: 1,
                    decay: 0.05
                });
            }
        }

        function createCoinSparkle(x, y) {
            for (let i = 0; i < 5; i++) { // Few particles for sparkle
                particles.push({
                    x: x,
                    y: y,
                    size: Math.random() * 1 + 1,
                    color: '#FFFFFF', // White sparkle
                    speedX: (Math.random() - 0.5) * 1,
                    speedY: (Math.random() - 0.5) * 1,
                    alpha: 1,
                    decay: 0.08
                });
            }
        }

        // --- Game Loop and Update Functions ---
        function update(deltaTime) {
            if (gameState !== 'PLAYING') return;

            // Update player horizontal movement
            player.speedX = 0;
            // The actual player horizontal speed will be relative to gameSpeed
            const horizontalMoveSpeed = 1.0; // Base speed, not directly scaled by gameSpeed here
            if (keys['ArrowLeft'] || touchControls.left) {
                player.speedX = -horizontalMoveSpeed;
            }
            if (keys['ArrowRight'] || touchControls.right) {
                player.speedX = horizontalMoveSpeed;
            }
            player.x += player.speedX;
            // Clamp player horizontal position
            player.x = Math.max(0, Math.min(GAME_WIDTH - player.width, player.x));

            // Apply gravity
            player.velocityY += player.gravity; // Gravity is constant, not scaled by gameSpeed directly

            // Apply jetpack thrust
            if (keys[' '] || touchControls.jetpack) {
                player.velocityY = player.jetpackThrust; // Thrust is constant
                createJetpackFlame(player.x, player.y); // Create flame particles
            }

            player.y += player.velocityY;

            // Check for ground/ceiling collision
            if (player.y + player.height > GAME_HEIGHT - 4) { // 4 is ground thickness
                player.y = GAME_HEIGHT - 4 - player.height;
                player.velocityY = 0;
            }
            if (player.y < 4) { // 4 is ceiling thickness
                player.y = 4;
                player.velocityY = 0;
            }

            // Update obstacles
            obstacles = obstacles.filter(obstacle => {
                obstacle.x -= backgroundScrollSpeed * gameSpeed; // Obstacles scroll faster with gameSpeed
                // Collision with player
                if (player.x < obstacle.x + obstacle.width &&
                    player.x + player.width > obstacle.x &&
                    player.y < obstacle.y + obstacle.height &&
                    player.y + player.height > obstacle.y) {
                    // Only lose a life if not already in invincible state
                    if (!player.invincible) {
                        lifelines--;
                        updateLifelinesDisplay();
                        player.invincible = true;
                        player.invincibleTimer = 60; // ~1 second at 60fps
                        // Optional: Add a visual flash or sound here
                        if (lifelines <= 0) {
                            gameOver();
                            return false;
                        }
                    }
                }
                return obstacle.x + obstacle.width > 0;
            });

            // Invincibility timer after hit
            if (player.invincible) {
                player.invincibleTimer--;
                if (player.invincibleTimer <= 0) {
                    player.invincible = false;
                }
            }

            // Update coins
            coins = coins.filter(coin => {
                coin.x -= backgroundScrollSpeed * gameSpeed; // Coins scroll faster with gameSpeed
                // Collision with player (collect coin)
                if (player.x < coin.x + coin.width &&
                    player.x + player.width > coin.x &&
                    player.y < coin.y + coin.height &&
                    player.y + player.height > coin.y) {
                    score += 10;
                    updateHUD();
                    createCoinSparkle(coin.x + coin.width / 2, coin.y + coin.height / 2); // Sparkle effect
                    return false; // Remove coin
                }
                return coin.x + coin.width > 0; // Keep if still on screen
            });

            // Update particles
            particles = particles.filter(p => {
                p.x += p.speedX;
                p.y += p.speedY;
                p.alpha -= p.decay;
                return p.alpha > 0;
            });

            // Obstacle spawning logic
            if (Date.now() - obstacleSpawnTimer > obstacleSpawnInterval / gameSpeed) { // Spawn faster with gameSpeed
                spawnObstacle();
                obstacleSpawnTimer = Date.now();
                // Gradually increase difficulty (reduce interval, but not below a minimum)
                obstacleSpawnInterval = Math.max(600, obstacleSpawnInterval - 10 * gameSpeed); // More aggressive reduction
            }

            // Coin spawning logic
            if (Date.now() - coinSpawnTimer > coinSpawnInterval / gameSpeed) { // Spawn faster with gameSpeed
                spawnCoin();
                coinSpawnTimer = Date.now();
            }

            // Increase score over time (distance flown)
            score += 0.1 * gameSpeed;
            updateHUD();

            // Gradually increase game speed
            gameSpeed += 0.0001; // Small increment
            gameSpeed = Math.min(3.0, gameSpeed); // Max speed limit, adjusted slightly
        }

        function startCountdownAndGame() {
            let count = 3;
            countdownNumber.textContent = count;
            countdownOverlay.classList.remove('hidden');
            startScreen.classList.add('hidden');
            instructionsScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            hud.classList.add('hidden');

            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownNumber.textContent = count;
                } else if (count === 0) {
                    countdownNumber.textContent = "GO!";
                } else {
                    clearInterval(countdownInterval);
                    countdownOverlay.classList.add('hidden');
                    startGame();
                }
            }, 1000);
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear entire canvas

            // Draw ceiling (top)
            drawPixelRect(0, 0, GAME_WIDTH, 4, '#B22222'); // Firebrick red

            // Draw ground (bottom)
            drawPixelRect(0, GAME_HEIGHT - 4, GAME_WIDTH, 4, '#556B2F'); // Dark Green

            // Draw player
            drawPixelArt(player.x, player.y, playerPixelArt);

            // Draw obstacles (as solid red rectangles)
            obstacles.forEach(obstacle => {
                drawPixelRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height, obstacle.color);
            });

            // Draw coins (yellow)
            coins.forEach(coin => {
                drawPixelArt(coin.x, coin.y, coinPixelArt);
            });

            // Draw particles (jetpack flames, coin sparkles)
            particles.forEach(p => {
                ctx.globalAlpha = p.alpha;
                drawPixelRect(p.x, p.y, p.size, p.size, p.color);
                ctx.globalAlpha = 1; // Reset alpha
            });
        }

        let lastTime = 0;
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            if (gameState === 'PLAYING') {
                update(deltaTime);
                render();
            }
            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---

        // Keyboard Controls
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ' && gameState === 'PLAYING') {
                e.preventDefault(); // Prevent spacebar from scrolling page
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Mobile Touch Controls
        // Use preventDefault to stop scrolling/zooming on touch interactions
        moveLeftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); touchControls.left = true; });
        moveLeftBtn.addEventListener('touchend', () => touchControls.left = false);
        moveRightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); touchControls.right = true; });
        moveRightBtn.addEventListener('touchend', () => touchControls.right = false);
        jetpackBtn.addEventListener('touchstart', (e) => { e.preventDefault(); touchControls.jetpack = true; });
        jetpackBtn.addEventListener('touchend', () => touchControls.jetpack = false);

        // UI Button Handlers
        startGameBtn.addEventListener('click', startCountdownAndGame);
        restartGameBtn.addEventListener('click', startCountdownAndGame);


        showInstructionsBtn.addEventListener('click', () => {
            startScreen.classList.add('hidden');
            instructionsScreen.classList.remove('hidden');
        });

        backToStartBtn.addEventListener('click', () => {
            instructionsScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
        });
        localStorage.setItem('score_jet_pack', score);
        // Initial setup
        window.onload = function () {
            initGame();
            updateHUD(); // Display initial score
            personalBestDisplay.textContent = personalBest; // Update PB on start screen
            gameLoop(0); // Start the loop to render initial screen
        };

    </script>
</body>

</html>
